/* 
## 문제파악 및 전략
1~N의 정점으로 이루어진 하나의 그래프 정보와 방문 순열을 줄 때 
BFS로 1부터 탐색을 할 때 인접한 점을 순서업이 큐에 넣을 수 있는데 
주어진 순열이 방문 순서가 될 수 있는지를 파악해서 1 또는 0을 출력하는 문제이다. 

전략 1
!모든 방문 순열을 다 완성해본 뒤에 원본과 대조해볼 수 밖에 없을 것 같다
?그럼 모든 가능한 방문 순서를 어떻게 만들어 볼 수 있을것인가?

bfs로 탐색을 할 때, 노드를 꺼내서 인접한 노드를 큐에 넣는 과정에서 모든 순서를 생성해서 넣어봐야 할 것 같음
그러면 반복되는 각 호출마다 다른 큐를 사용해야 할 것 같고. 복사해서 사용해야 할 것 같다. 
이때 순서를 바꿔거며 넣어줘야 한다. 그러면 visit과 큐 또한 복사해서 호출로 넘겨주어야 하고, 복사해서 사용해야 한다.
그래도 이렇게 진행해 볼 경우, 만든 순열과 함께 호출이 끝나고 완성되었을 때마다 대조해서 일치하는 경우에 바꿔주고 
찾았다면 모든 호출을 무효화할 수 있도록 flag를 사용해서 0 또는 1인지에 따라 할 수 있을 것이다. 
이때 큐는 순열을 쉽게 만들려면 배열을 사용해야 할 것 같다. 

정점의 수가 10만까지 들어올 수 있는게 문제될 수 있다. 각 호출마다 연결된 노드들의 가능한 모든 순열이 생성될 것인데
그럼 많은 경우의 수가 생길것이다. 시간 제한은 2초로 짧지 않기는 한데 10만개의 노드에서 가능할지는 모르겠음. 

전략 2
depth를 활용해볼 수 있을까?
bfs에서 큐에서 나오는 순서는 같은 depth안에서는 다를 수 있지만 defph 순서대로 나올 수밖에 없다. 
그러므로 depth가 달라질 때마다 이전까지 depth에서 꺼낸 것들을 저장하며 오다가 저장된 depth로 만들 수 있는 순열인지를 파악하는것이다. 
그렇게 할 경우 초기에 flag를 1로 설정해 두고 depth별로 가능여부를 파악하기 때문에 중간에 판단하고 빠져나올 수 있을 것이고, 
탐색 과정이 한번밖에 되지 않기 때문에 더 좋은 방법인 것 같다. 

이를 위해서는 전역 레벨에서 flag와, 주어진 순열에서의 검사 순서를 기록할 curIndex 변수, depth별로 원소를 저장할 배열,
그리고 탐색에 필요한 visit변수, 큐를 가지고 있으면 된다. 

필요한 함수는
bfs와 순열을 생성해서 제시된 순열과 비교하는 함수가 필요하다. 

2번 전략으로 진행해본다. 우선 큐는 배열을 사용해서 구현해보도록 하고. 큐로 대체해서 진행해볼것이다. 
*/

const [N, ...lines] = `4
1 2
1 3
2 4
1 2 3 4`
  .trim()
  .split('\n');

const n = Number(N);
const testLine = lines.pop(); // 순열은 배열로 만들 것이기 때문에 join해서 문자열로 비교할것이다.
const adj = Array.from({ length: n + 1 }, () => []); // 인덱스 활용할것

for (const line of lines) {
  const [a, b] = [line[0], line[2]];
  adj[a].push(b);
  adj[b].push(a);
}
