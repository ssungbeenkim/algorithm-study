/* 
0 ~ N까지의 정수 K개를 더해서 합이 N이 되는 경우의 수를 구하라. 
한개의 수를 여러번 사용할 수도 있다. 
입력 N, K 
20 2 
21 
0 1 2 3 4 5 ... 20 : 21가지 


푼 방법 
경우의 수를 나열해 보면 n값에 관계없이 k = 1이면 1가지 
k가 2이면 n+1가지가 된다. 
그리고 배열 d를 0 ~ n+1의 값으로 채우고 시작할 때,  
k가 3이면 d의 모든 값을 더한 값이 된다. 이를 효율적으로 구하기 위해 dp방식으로 d'을 만들었다.  
k가 4이면 마찬가지로 d'의 모든 값을 더한 값이 답이 된다. d'' 을 만들어 구한다. 
...
k가 n이면 같은 방식으로 구한 배열의 [n+1]의 값이 최종 경우의 수가 된다. 
값이 매우 커지므로 중간중간에 mod연산을 해 주었고, mod연산 분배법칙에 의거하여 마이막에 답을 리턴할 때 
한번 더 나누어 주었다. 
꼬박 이틀에 걸쳐 스스로 풀었고 규칙을 진작에 찾았지만 이를 코드로 어떻게 표현할까 고민을 많이 한 문제였다. 
역시 풀리지 않을 문제는 없다. 물리적 시간이 걸릴 뿐이다. 
*/
const [n, k] = `1 3`.trim().split(/\s/).map(Number);

const d = [];
for (i = 0; i <= n + 1; i++) {
  d.push(i);
}
console.log(returnAns(k));
function returnAns(k) {
  if (k === 1) {
    return 1;
  }
  if (k === 2) {
    return n + 1;
  }
  if (k >= 3) {
    for (let i = 3; i <= k; i++) {
      for (let j = 1; j <= n + 1; j++) {
        d[j] = (d[j - 1] % 1000000000) + (d[j] % 1000000000);
      }
    }
    return d[n + 1] % 1000000000;
  }
}
