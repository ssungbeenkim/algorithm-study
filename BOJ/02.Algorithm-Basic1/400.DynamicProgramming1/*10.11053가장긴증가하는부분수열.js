/* 
문제를 보고 생각이 들었다. 
뭔 개소리야?
https://namu.wiki/w/%EC%B5%9C%EC%9E%A5%20%EC%A6%9D%EA%B0%80%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4
최장 증가 부분 수열 문제라는 것은 DP로 풀 수 있는 유명한 유형의 알고리즘이라고 한다. 
(LIS: Longest Increasing Subsequence)

만들수 있는 부분수열 중에서 
오름차순인 것 중에서 
가장 긴것을 찾는 문제이다. 

그냥 다찾아본다고 했을 때 
길이가 1인것부터 찾아본다면? 
....

원소를 하나씩 돌면서 새로운 배열에 추가하되, 더 작은게 나오면 패스하면 어떨까?
6
10 20 10 30 20 50 에서 
10 20 p 30 p 50 으로 바로 찾을 수 있지 않을까?
만약 그렇게 된다면 
10 20 30 10 11 12 13 14 15 16 17 의 경우 
10 30 30 p p p p p p p p 가 되어 제대로 찾을 수가 없을것이다. 

10분만 더 고민해 보자. 

n만큼의 2차원 배열을 만들어 두고. 
[[0] [0] [0] [0] [0] [0]]
for문을 돌면서 해당 인댁스부터 만들 수 있는 증가 부분수열의 갯수를 카운트 한다. 
그 다음 가장 큰것을 골라 출력하면 되지 않을까. 
for문은 n번을 돌게 되니, 해볼만 한 것 같다.
근데, 이렇게 하면 위와 동일한 문제가 발생해서 안될것같음. 

찾아보자. 

https://yabmoons.tistory.com/516 
생각보다 너무 간단한 아이디어로 풀 수 있었다. 
각 인덱스의 값마다 그 값까지 가질 수 있는 최대 배열을 만들어 따로 값을 저장하고 
최대값을 출력하면 된다. 
 */

const [n, ...input] = `6
10 20 10 30 20 50`
  .trim()
  .split(/\s/)
  .map(Number);
const dp = Array(n).fill(0);

input.forEach((v, i) => {
  if (i === 0) {
    dp[i] = 1;
  } else {
    //이전 index의 값들중에서
    //현제 값보다 작은 값 중에서
    //가장 긴 부분순열 + 1을 현제 index 부분수열 길이 값으로 저장
    //이전의 값들 중 더 작은 값이 없으면 길이는 1로 저장할 것이다.
    let best = 0;
    input.slice(0, i).forEach((n, j) => {
      if (n < v && dp[j] > best) {
        best = dp[j];
      }
    });
    dp[i] = best + 1;
  }
});

console.log(Math.max(...dp));

/* 문제의 아이디어를 얻어서 잘 풀었는데 조금 복잡하게 코드를 적은것이 아닌지 생각이 들어 
조금 더 찾아본다. 

- slice를 안하고 index로 for문을 돌렸으면 되었다. 
*/
