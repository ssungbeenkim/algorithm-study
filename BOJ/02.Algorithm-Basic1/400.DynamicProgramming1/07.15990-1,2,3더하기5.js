/* 
각 식은 1,2,3중의 하나로 시작할 수 있고, 
En 은 En-1 En-2 En-3을 참조해서 만들어 지지만 같은 수를 연속해서 사용하면 안된다. 
각 식은 2차원 배열로 만들고 편의를 위해 4개의 크기로 만든다. 
1,2,3번 인덱스의 값은 각 인덱스의 숫자로 시작하는 식의 갯수이다. 
이렇게 만들어나가면 n까지 식의 구성을 구할 수 있고, 
n을 출력하면 된다. 
*/
{
  const [t, ...ns] = `1
99991`
    .trim()
    .split(/\s/)
    .map(Number);
  const upTo = Math.max(...ns);
  const e = Array(upTo + 1).fill([0n, 0n, 0n, 0n]);
  e[1] = [0n, 1n, 0n, 0n];
  e[2] = [0n, 0n, 1n, 0n];
  e[3] = [0n, 1n, 1n, 1n];
  for (i = 4; i < upTo + 1; i++) {
    e[i] = [
      0n,
      e[i - 1][2] + e[i - 1][3],
      e[i - 2][1] + e[i - 2][3],
      e[i - 3][1] + e[i - 3][2],
    ];
  }
  const answer = [];
  ns.forEach((n) => {
    answer.push(e[n].reduce((p, c) => (p + c) % 1000000009n));
  });
  console.log(answer.join('\n'));
} // 틀려서 큰 수의 경우에 대비해서 bigint값을 사용하도록 했는데 시간초과가 난다.

/* 
우선 쓸데없이 배열을 채우고 시작하지 않았다. 
그리고 편의상 4개로 했는데 배열의 3으로 필요한 부분만 만들도록 바꿔 주었다. 
이렇게 해도 시간초과가 나서 찾아 보았는데.. 
다른 풀이를 보니 Bigint를 사용하지 않고 있었다.  
그리고 특이하게 가짓수마다 나눠주고 있었다. 
그렇게 하니 정답이 나오기는 하는데..
왜 각각의 경우를 1000000009로 나눠주고 또 마지막에 한번 더 나눠주는 것인지 이해가 안간다.
=> 모듈러 연산(mod연산)의 분배법칙이라는 것이 있다.
bigInt로 해결하려 했지만 계산 과정이 무거워지고 저장 메모리도 커지니 시간초과가 났던 것이다. 
중간중간에서 모듈러 연산을 해주어야 했던 것이었다....
마지막에 한번에 나누기 힘들고 계산 과정에서 이미 overFlow가 되어 버리는 경우에는 
중간에 modulo 연산을 해줘야 할 때 알아야 할 개념인 듯 하다. 
*/
{
  // 정답
  const [t, ...ns] = `3
4 7 10`
    .trim()
    .split(/\s/)
    .map(Number);
  const upTo = Math.max(...ns);
  const e = Array(upTo + 1).fill([0, 0, 0, 0]);
  e[1] = [1, 0, 0];
  e[2] = [0, 1, 0];
  e[3] = [1, 1, 1];
  for (i = 4; i < upTo + 1; i++) {
    e[i] = [
      (e[i - 1][1] + e[i - 1][2]) % 1000000009,
      (e[i - 2][0] + e[i - 2][2]) % 1000000009,
      (e[i - 3][0] + e[i - 3][1]) % 1000000009,
    ];
  }
  const answer = [];
  ns.forEach((n) => {
    answer.push(e[n].reduce((p, c) => (p + c) % 1000000009));
  });
  console.log(answer.join('\n'));
}
