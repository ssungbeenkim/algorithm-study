/* 1로 만들기 
3가지 연산으로 1로 만든다. 
- X가 3으로 나누어 떨어지면, 3으로 나눈다.
- X가 2로 나누어 떨어지면, 2로 나눈다.
- 1을 뺀다.
각 계산은 1회의 연산으로 값을 누적시킨다. 
가장 적은 연산 횟수를 구한다. 
힌트를 보면, 2,3으로 나누어 떨어지더라도 1을 먼저 빼도 된다. 

solution 
전체 계산의 경우의 수를 다 세보고 해야 할 것 같다. 
계산 속도를 높이기 위해서는 계산 결과를 캐싱해야 할 것 같음. 
동적계획법에 익숙하지 않고 뭔가 막연하니 10분 생각해보고 참고해서 풀자. 23분까지. 

모든 경우를 계산. 
1이 나오는 경우 count를 정답에 추가. 
모든 경우를 다 세면 
최소값을 출력. 
 */

/* 
DP에 대한 이해가 필요하다. 
https://www.youtube.com/watch?v=0bqfTzpWySY 
*/

const n = Number(`10`.trim());

const dp = Array(n + 1).fill(0);

for (i = 2; i < n + 1; i++) {
  dp[i] = dp[i - 1] + 1;
  if (!(i % 2)) {
    dp[i] = Math.min(dp[i / 2] + 1, dp[i]);
  }
  if (!(i % 3)) {
    dp[i] = Math.min(dp[i / 3] + 1, dp[i]);
  }
}

console.log(dp[n]);

/* DP를 활용한 첫 문제였다. 작은 값부터 캐싱해서 최소 연산으로 결과값을 캐싱하며 
효율적으로 연산을 수행해서 저장해 둔 뒤 목표 수를 출력하는 방식이다.*/
