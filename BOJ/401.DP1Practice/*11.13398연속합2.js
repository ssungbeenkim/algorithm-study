/* 
연속합을 구한다. 
10 -4 3 1 5 6 -35 12 21 -1
10 6 9 10 15 21 -14* 12 33 -1
10 6 9 10 15 21 21* 33 54 53
dp[n]은 입력으로 들어온 n번째 수까지의 최대 연속합이다. 
인덱스로 값을 돌면서 dp의 요소를 설정한다. 
음수가 되면 다음 값에서는 새로 시작하도록 한다. 
최대값을 출력하면 가장 큰 연속합을 구할 수 있다. 
근데, 한번까지는 빼고 합할 수 있다. 
빼야 할 때는 음수일때이며 진행되고 있는 연속합에서 한번 뺄 수 있다. 
*/

/* 
반례를 찾아보자. 
`8
1 -3 4 8 -4 -3 9 2`
18 
20?
-1 -1 -1
-1 -1 
*/

// {
//   const [n, ...input] = `3
// -1 -4 -3`
//     .trim()
//     .split(/\s/)
//     .map(Number);

//   const dp = [];
//   let chance = 1;

//   for (let i = 0; i < n; i++) {
//     // 이전 값이 음수인 경우 초기화.
//     if (dp[i - 1] < 0) {
//       // 첫 값은 여기로 안들어옴.
//       dp[i] = input[i];
//     } else if (i === 0) {
//       // 첫번째 값이면 첫 값으로 해준다. 음수이면 깍아준다.
//       if (dp[i] < 0) {
//         chance--;
//       }
//       dp[i] = input[i];
//     } else {
//       const newItem = input[i] + dp[i - 1];
//       if (newItem < 0) {
//         // newItem 음수인 경우 chance-- 해주고 음수이면 새 값으로 재시작. 아니면 재활용.
//         chance--;
//         if (chance < 0) {
//           dp[i] = newItem;
//           chance = 1;
//         } else {
//           dp[i] = dp[i - 1];
//         }
//       } else {
//         // 양수인 경우.
//         dp[i] = newItem;
//       }
//     }
//   }

//   console.log(Math.max(...dp));
// }
/* 답이 맞게 나오고 반례도 다 맞게 나온다. 하지만 풀이를 통과하지 못한다. 
조금 어렵게 푼 감이 있고 그냥 되는대로 푼 것 같다. 가독성이 떨어져서 어디가 문제인지도 
파악하기가 쉽지가 않다. 
다른 풀이를 참고해 보니 훨씬 가독성도 좋고 좋은 방법이 있어서 이용해서 다시 풀도록 한다. 
*/
